### tips in Cmake
***
1. 指令不区分大小写，统一即可。add_executable(hello main.cpp)
1. 参数、变量严格大小写，${}来引用变量
1. include_directories 编译器查找相应头文件
1. set () 用变量代替值
1. add_subdirectory() 向当前工程添加存放源文件的子目录
1. 将函数实现部分封装成库，并将函数的定义写在头文件中，如下所示：
***
### tips in C++
```C++
#ifndef BASE_H
#define BASE_H

#include <opencv2/core/core.hpp>

cv::Mat distort_image(cv::Mat image);

#endif

add_library(lib_undistort {PROJECT_SOURCE_DIR}/SOURCE/distort.cpp)
target_link_libraries(lib_undistort ${OpenCV_LIBS})
```
***
7. 静态库：编译时将源代码复制到程序中，运行时不依赖库文件，但占用空间较大。动态库：加载库过程需要一定时间，重新编译时不需要编译库文件。
```c++
cmake -DCMAKE_INSTALL_PREFIX=dir .. make clean (重新cmake)
set(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/bin) // 将执行文件输入到bin文件夹下
```
8. clion tips: ctrl + N 导航到类名 调试程序时将CMAKElists 中的模式修改为debug    
9. unique_ptr<A> ptr_name(new A(args));  动态管理内存，避免由于delete 之前的代码错误导致的delete功能失效，相比于普通指针，该指针不能拷贝、赋值，但可以作为返回类型。make_unique<A>(args) ,减少了代码数量 
10. share_ptr: 通过计数方式共享同一段内存，开辟新的内存用于引用计数，内存占用高，使用场景：多个对象使用同一块内存，或者在对象析构时转移到其他线程；unique_ptr:没有拷贝构造函数，有移动构造，两者都不允许隐式类型转化，性能最优;weak_ptr:简单理解为不会引起引用计数
11. 顶层const:指针不可改变；底层const:指针所指内容不可改变            
12. explicit 防止单变量的构造函数隐式自动转化（转化为该类的对象）；当类的构造函数包含多个参数时，该关键字的作用无效                   
13. static_cast dynamic_cast 后者由于存在如虚函数之类的类型检查，转换过程更安全
14. volatile 用来设定某个对象的存储位置在内存中，而不是寄存器中，常用于多线程下。
15. array new array delete pca;内存泄漏：开辟的内存空间使用完毕后未能回收
16. C++ 好的特性：1.内存泄漏：智能指针；2.容器，内存管理错误；3.范围推断，auto; 4. lambda 表达式；5.基于范围的循环
17. 多线程安全：一个进程中的多线程共享进程内存空间中的全局、静态存储区时，如果一个函数包含全局、静态变量，可能导致线程不安全；原子操作：CPU执行过程中不会被中断，可见性：多级缓存结构解决了读取数据效率较低，但由于主内存更新的滞后性，导致内存不安全；解决方法：线程按照规定的先后顺序运行，互斥锁的引入。
18. 病态矩阵定义：随机扰动引起的解的误差增大，判断条件：条件数远大于一，最大奇异值与最小奇异值的比值；解决方法，利用SVD分解的正交基作为解集的基
19. 舒尔补：（边缘化某个变量，即固定该变量的估计值，求解其他变量在该变量下的条件概率）求解BA过程中，由于H矩阵的稀疏性，通常选择边缘化某个变量，数学上来说即对矩阵进行舒尔消元，化为上三角矩阵或下三角矩阵。一方面加快了优化的求解速度，一方面降低了矩阵的条件数，解的精确性得到提高。
20. ceres autodiff 原理：定义了一种jet数据类型，该类存放了函数值和函数关于变量的偏导数，重载乘法、加法、指数运算等一系列操作符实现求导。
***
### tips in vslam

1. 后端优化过程中，一般出现的是方程个数远超未知量个数的情况，属于超定方程，通常转化为最小二乘问题求解，最后转化为增量方程的求解 Ax = b,通常对系数矩阵进行分解，一方面降低存储空间和运算量，一方面提高解的稳定性。QR分解：满秩方阵，Q为正交阵，R为上三角；choesky分解，满秩矩阵，分解为下三角矩阵和其装置的乘积；SVD分解，矩阵，分解正交阵、对角阵、正交阵的乘积

2. 逆深度，在极限搜索和块匹配时，特征点深度为无穷远时，无法用高斯分布描述它，同时在BA过程中优化特征点时，远距离的特征点误差随之增大，故引入逆深度技巧。  
3. 极限搜索和块匹配：
4. 回环检测：基于词袋，基于深度学习网络的，posenet(输出图片的位姿) cacl
5. FEJ:第一次估计雅各比，由于滑动窗口存在的旧帧剔除问题，剔除意味着固定某一帧（边缘化某一帧）这时需要将该帧观察到的信息在矩阵置零，故引入舒尔补的概念，即求解该帧的舒尔补，将帧的先验信息（对应到矩阵就是不再更新的变量）保留下来，<font color=green>__先验信息包括先验信息矩阵和残差矩阵，由于先验信息矩阵对剩余变量的雅各比不变，而残差矩阵对于剩余变量的雅各比还在变化即不同残差对同一状态变量求雅各比时线性化点不一致会导致零空间退化问题，需要将__</font><font face=宋体 color=red>*_第一次估计的雅各比矩阵作为之后的雅各比，而只更新残差和优化变量_*。</font>
6. slam系统的可观性：如果状态不同，测量值也不同则认为系统可观。单目slam,6自由度姿态不可观，1自由度尺度不可观；单目+IMU：yaw自由度不可观，x\y\z三个平移自由度不可观（具体例子，将相机转移到不同位置，对同一个地标的观测可能具有相同测量值）
7. 视觉稠密建图与视觉里程计的区别，我们无法将每个像素都当作特征点来计算（直接法**最小亮度误差**另说）所以缺少了特征匹配（*通常有描述子匹配和光流匹配*）之后，我们需要知道相同特征点在不同图像中的位置，为此引入极限搜索和块匹配。立体视觉匹配（单目、双目匹配）存在对物理纹理的依赖性（对于一些梯度不明显的图像，单目中的极线搜索可能出现误匹配（灰度值过于类似），双目中（在左右像素点的匹配过程也有可能出现问题）



