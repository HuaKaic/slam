### tips in Cmake
***
1. 指令不区分大小写，统一即可。add_executable(hello main.cpp)
1. 参数、变量严格大小写，${}来引用变量
1. include_directories 编译器查找相应头文件
1. set () 用变量代替值
1. add_subdirectory() 向当前工程添加存放源文件的子目录
1. 将函数实现部分封装成库，并将函数的定义写在头文件中，如下所示：
***
### tips in C++
```C++
#ifndef BASE_H
#define BASE_H

#include <opencv2/core/core.hpp>

cv::Mat distort_image(cv::Mat image);

#endif

add_library(lib_undistort {PROJECT_SOURCE_DIR}/SOURCE/distort.cpp)
target_link_libraries(lib_undistort ${OpenCV_LIBS})
```
***
7. 静态库：编译时将源代码复制到程序中，运行时不依赖库文件，但占用空间较大。动态库：加载库过程需要一定时间，重新编译时不需要编译库文件。
```c++
cmake -DCMAKE_INSTALL_PREFIX=dir .. make clean (重新cmake)
set(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/bin) // 将执行文件输入到bin文件夹下
```
8. clion tips: ctrl + N 导航到类名 调试程序时将CMAKElists 中的模式修改为debug    
9. unique_ptr<A> ptr_name(new A(args));  动态管理内存，避免由于delete 之前的代码错误导致的delete功能失效，相比于普通指针，该指针不能拷贝、赋值，但可以作为返回类型。make_unique<A>(args) ,减少了代码数量 
10. share_ptr: 通过计数方式共享同一段内存，开辟新的内存用于引用计数，内存占用高，使用场景：多个对象使用同一块内存，或者在对象析构时转移到其他线程；unique_ptr:没有拷贝构造函数，有移动构造，两者都不允许隐式类型转化，性能最优;weak_ptr:简单理解为不会引起引用计数
11. 顶层const:指针不可改变；底层const:指针所指内容不可改变            
12. explicit 防止单变量的构造函数隐式自动转化（转化为该类的对象）；当类的构造函数包含多个参数时，该关键字的作用无效                   
13. static_cast dynamic_cast 后者由于存在如虚函数之类的类型检查，转换过程更安全
14. volatile 用来设定某个对象的存储位置在内存中，而不是寄存器中，常用于多线程下。
15. array new array delete pca;内存泄漏：开辟的内存空间使用完毕后未能回收
16. C++ 好的特性：1.内存泄漏：智能指针；2.容器，内存管理错误；3.范围推断，auto; 4. lambda 表达式；5.基于范围的循环
17. 多线程安全：一个进程中的多线程共享进程内存空间中的全局、静态存储区时，如果一个函数包含全局、静态变量，可能导致线程不安全；原子操作：CPU执行过程中不会被中断，可见性：多级缓存结构解决了读取数据效率较低，但由于主内存更新的滞后性，导致内存不安全；解决方法：线程按照规定的先后顺序运行，互斥锁的引入。
18. 病态矩阵定义：随机扰动引起的解的误差增大，判断条件：条件数远大于一，最大奇异值与最小奇异值的比值；解决方法，利用SVD分解的正交基作为解集的基
19. 舒尔补：（边缘化某个变量，即固定该变量的估计值，求解其他变量在该变量下的条件概率）求解BA过程中，由于H矩阵的稀疏性，通常选择边缘化某个变量，数学上来说即对矩阵进行舒尔消元，化为上三角矩阵或下三角矩阵。一方面加快了优化的求解速度，一方面降低了矩阵的条件数，解的精确性得到提高。
20. ceres autodiff 原理：定义了一种jet数据类型，该类存放了函数值和函数关于变量的偏导数，重载乘法、加法、指数运算等一系列操作符实现求导。
***
### tips in vslam

1. 后端优化过程中，一般出现的是方程个数远超未知量个数的情况，属于超定方程，通常转化为最小二乘问题求解，最后转化为增量方程的求解 Ax = b,通常对系数矩阵进行分解，一方面降低存储空间和运算量，一方面提高解的稳定性。QR分解：满秩方阵，Q为正交阵，R为上三角；choesky分解，满秩矩阵，分解为下三角矩阵和其装置的乘积；SVD分解，矩阵，分解正交阵、对角阵、正交阵的乘积

2. 逆深度，在极限搜索和块匹配时，特征点深度为无穷远时，无法用高斯分布描述它，同时在BA过程中优化特征点时，远距离的特征点误差随之增大，故引入逆深度技巧。  

3. 极限搜索和块匹配：

4. 回环检测：基于词袋，基于深度学习网络的，posenet(输出图片的位姿) cacl

5. FEJ:第一次估计雅各比，由于滑动窗口存在的旧帧剔除问题，剔除意味着固定某一帧（边缘化某一帧）这时需要将该帧观察到的信息在矩阵置零，故引入舒尔补的概念，即求解该帧的舒尔补，将帧的先验信息（对应到矩阵就是不再更新的变量）保留下来，<font color=green>__先验信息包括先验信息矩阵和残差矩阵，由于先验信息矩阵对剩余变量的雅各比不变，而残差矩阵对于剩余变量的雅各比还在变化即不同残差对同一状态变量求雅各比时线性化点不一致会导致零空间退化问题，需要将__</font><font face=宋体 color=red>*_第一次估计的雅各比矩阵作为之后的雅各比，而只更新残差和优化变量_*。</font>

6. slam系统的可观性：如果状态不同，测量值也不同则认为系统可观。单目slam,6自由度姿态不可观，1自由度尺度不可观；单目+IMU：yaw自由度不可观，x\y\z三个平移自由度不可观（具体例子，将相机转移到不同位置，对同一个地标的观测可能具有相同测量值）

7. 视觉稠密建图与视觉里程计的区别，我们无法将每个像素都当作特征点来计算（直接法**最小亮度误差**另说）所以缺少了特征匹配（*通常有描述子匹配和光流匹配*）之后，我们需要知道相同特征点在不同图像中的位置，为此引入极限搜索和块匹配。立体视觉匹配（单目、双目匹配）存在对物理纹理的依赖性（对于一些梯度不明显的图像，单目中的极线搜索可能出现误匹配（灰度值过于类似），双目中（在左右像素点的匹配过程也有可能出现问题）

8. vslam评价指标：相对位姿误差（RPE)  绝对轨迹误差（ATE) 

    1. 相对位姿误差：主要描述固定时间间隔内的局部精度：定义第i帧的RPE如下

    $$
    E_i = (Q^{-1}_iQ_{i + \Delta})^{-1}P^{-1}_iP_(i+\Delta)
    $$

    其中P、Q分别表示实际位姿和计算位姿。

    当我们有n个相机位姿时，我们以$\Delta$为时间间隔进行计算相对位姿误差时，通常计算平移分量的均方根误差，即
    $$
    RMSE(E_{1 : n}, \Delta) = (\frac{1}{m}\sum_{i=1}^{m}||trans(E_i)||^2)^{\frac{1}{2}}
    $$
    其中trans指的是相对位姿误差$E_i$的平移分量

    2. 绝对轨迹误差：估计轨迹的全局一致性。全局一致性可以通过比较估计轨迹和地面真实轨迹之间的绝对距离评估。故需要找到一种变换关系将估计轨迹映射到地面轨迹上，可以利用HORM方法实现。
       $$
       F_i = Q_i^{-1}SP_i
       $$
       同样在平移分量上计算所有时间上的均方根误差
       $$
       RMSE(F_{1:n}) = (\frac{1}{m}\sum_{i=1}^{m}||trans(F_i)||^2)^{\frac{1}{2}}
       $$
       RPE考虑平移和旋转误差，而ATE只考虑平移误差。因此，<font color=green>RPE总是略大于ATE（如果没有旋转误差，则等于），因此RPE度量提供了一种将旋转误差和平移误差组合成单一度量的优雅方法</font>。然而，*旋转误差通常也表现为错误的平移*，因此也间接地被ATE捕获。从实用的角度来看，**ATE具有直观的可视化**，便于目视检查。

       

    

9. 聚类、匹配算法；  
    Kmeans聚类（无监督）：随机选取k个中心点；  
                遍历剩余所有点，依据到中心点的最小距离作为归类；  
                计算每个类的中心点；
                如果中心点的变化较小，算法收敛，否则重复上述步骤  
    KNN（有监督）：查找样本的K个最近邻的样本分类，按每个近邻分类数量进行评估样本分类结果。运算复杂度大，引入K-dtree数据结构：

    k-dtree：

    FLANN（快速近似最近邻）
    
10.  假设检验剔除外点（卡方检验）

* 若k个随机变量Z1,Z2,...,ZkZ1,Z2,...,Zk是相互独立，符合标准正态分布的随机变量（数学期望为0、方差为1），则随机变量Z的平方和X=∑ki−1Z2iX=∑i−1kZi2被称为服从自由度为 k 的卡方分布，记作X∼χ2(k)X∼χ2(k)。

* 用途：检查变量分布与期望分布的拟合程度，一般用于检验样本偏离属于系统误差还是正常波动
* 步骤
  * 1. 给出检验假设和备择建设
    2.  计算期望
    3.  选择显著性水平和计算卡方统计量 $ x^2 = \frac{\sum(O - E)^2}{E}   $ 表示系统偏差与期望之间的差异
    4. 查表获得拒绝域的范围，并做出选择

* 在特征点法中的应用：

  * 单目投影自由度为2， 双目为3

  * 变量为地图点投影到像素坐标系上的坐标$ p^‘ $与像素坐标p之间的误差，误差服从高斯分布 
    $$
    e_i = p^` - p,e\sim N(0, \sigma), 其中 \sigma = (s^n * p)^2 \left(\begin{matrix} 1 & 0 \\ 0 & 1 \end{matrix}\right)
    $$

  * 为凑成高斯分布，利用协方差矩阵进行加权，获得
    $$
    (\sigma^-1 * e) \sim N(0, 1)
    $$

  * 故不同金字塔层的特征点具有不同方差，层数越高，方差愈大（不同金字塔层级的图像通过opencv中的resize实现，主要利用线性插值方式实现）
